// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class AddUnderlyingToken extends ethereum.Event {
  get params(): AddUnderlyingToken__Params {
    return new AddUnderlyingToken__Params(this);
  }
}

export class AddUnderlyingToken__Params {
  _event: AddUnderlyingToken;

  constructor(event: AddUnderlyingToken) {
    this._event = event;
  }

  get underlyingToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class AddYieldToken extends ethereum.Event {
  get params(): AddYieldToken__Params {
    return new AddYieldToken__Params(this);
  }
}

export class AddYieldToken__Params {
  _event: AddYieldToken;

  constructor(event: AddYieldToken) {
    this._event = event;
  }

  get yieldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class AdminUpdated extends ethereum.Event {
  get params(): AdminUpdated__Params {
    return new AdminUpdated__Params(this);
  }
}

export class AdminUpdated__Params {
  _event: AdminUpdated;

  constructor(event: AdminUpdated) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class ApproveMint extends ethereum.Event {
  get params(): ApproveMint__Params {
    return new ApproveMint__Params(this);
  }
}

export class ApproveMint__Params {
  _event: ApproveMint;

  constructor(event: ApproveMint) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ApproveWithdraw extends ethereum.Event {
  get params(): ApproveWithdraw__Params {
    return new ApproveWithdraw__Params(this);
  }
}

export class ApproveWithdraw__Params {
  _event: ApproveWithdraw;

  constructor(event: ApproveWithdraw) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get yieldToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Burn extends ethereum.Event {
  get params(): Burn__Params {
    return new Burn__Params(this);
  }
}

export class Burn__Params {
  _event: Burn;

  constructor(event: Burn) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class CreditUnlockRateUpdated extends ethereum.Event {
  get params(): CreditUnlockRateUpdated__Params {
    return new CreditUnlockRateUpdated__Params(this);
  }
}

export class CreditUnlockRateUpdated__Params {
  _event: CreditUnlockRateUpdated;

  constructor(event: CreditUnlockRateUpdated) {
    this._event = event;
  }

  get yieldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get blocks(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Deposit extends ethereum.Event {
  get params(): Deposit__Params {
    return new Deposit__Params(this);
  }
}

export class Deposit__Params {
  _event: Deposit;

  constructor(event: Deposit) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get yieldToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get recipient(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class Donate extends ethereum.Event {
  get params(): Donate__Params {
    return new Donate__Params(this);
  }
}

export class Donate__Params {
  _event: Donate;

  constructor(event: Donate) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get yieldToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Harvest extends ethereum.Event {
  get params(): Harvest__Params {
    return new Harvest__Params(this);
  }
}

export class Harvest__Params {
  _event: Harvest;

  constructor(event: Harvest) {
    this._event = event;
  }

  get yieldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get minimumAmountOut(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get totalHarvested(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get credit(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Initialized extends ethereum.Event {
  get params(): Initialized__Params {
    return new Initialized__Params(this);
  }
}

export class Initialized__Params {
  _event: Initialized;

  constructor(event: Initialized) {
    this._event = event;
  }

  get version(): i32 {
    return this._event.parameters[0].value.toI32();
  }
}

export class KeeperSet extends ethereum.Event {
  get params(): KeeperSet__Params {
    return new KeeperSet__Params(this);
  }
}

export class KeeperSet__Params {
  _event: KeeperSet;

  constructor(event: KeeperSet) {
    this._event = event;
  }

  get sentinel(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get flag(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class Liquidate extends ethereum.Event {
  get params(): Liquidate__Params {
    return new Liquidate__Params(this);
  }
}

export class Liquidate__Params {
  _event: Liquidate;

  constructor(event: Liquidate) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get yieldToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get underlyingToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get shares(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get credit(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class LiquidationLimitUpdated extends ethereum.Event {
  get params(): LiquidationLimitUpdated__Params {
    return new LiquidationLimitUpdated__Params(this);
  }
}

export class LiquidationLimitUpdated__Params {
  _event: LiquidationLimitUpdated;

  constructor(event: LiquidationLimitUpdated) {
    this._event = event;
  }

  get underlyingToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get maximum(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get blocks(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class MaximumExpectedValueUpdated extends ethereum.Event {
  get params(): MaximumExpectedValueUpdated__Params {
    return new MaximumExpectedValueUpdated__Params(this);
  }
}

export class MaximumExpectedValueUpdated__Params {
  _event: MaximumExpectedValueUpdated;

  constructor(event: MaximumExpectedValueUpdated) {
    this._event = event;
  }

  get yieldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get maximumExpectedValue(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class MaximumLossUpdated extends ethereum.Event {
  get params(): MaximumLossUpdated__Params {
    return new MaximumLossUpdated__Params(this);
  }
}

export class MaximumLossUpdated__Params {
  _event: MaximumLossUpdated;

  constructor(event: MaximumLossUpdated) {
    this._event = event;
  }

  get yieldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get maximumLoss(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class MinimumCollateralizationUpdated extends ethereum.Event {
  get params(): MinimumCollateralizationUpdated__Params {
    return new MinimumCollateralizationUpdated__Params(this);
  }
}

export class MinimumCollateralizationUpdated__Params {
  _event: MinimumCollateralizationUpdated;

  constructor(event: MinimumCollateralizationUpdated) {
    this._event = event;
  }

  get minimumCollateralization(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class Mint extends ethereum.Event {
  get params(): Mint__Params {
    return new Mint__Params(this);
  }
}

export class Mint__Params {
  _event: Mint;

  constructor(event: Mint) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class MintingLimitUpdated extends ethereum.Event {
  get params(): MintingLimitUpdated__Params {
    return new MintingLimitUpdated__Params(this);
  }
}

export class MintingLimitUpdated__Params {
  _event: MintingLimitUpdated;

  constructor(event: MintingLimitUpdated) {
    this._event = event;
  }

  get maximum(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get blocks(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class PendingAdminUpdated extends ethereum.Event {
  get params(): PendingAdminUpdated__Params {
    return new PendingAdminUpdated__Params(this);
  }
}

export class PendingAdminUpdated__Params {
  _event: PendingAdminUpdated;

  constructor(event: PendingAdminUpdated) {
    this._event = event;
  }

  get pendingAdmin(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class ProtocolFeeReceiverUpdated extends ethereum.Event {
  get params(): ProtocolFeeReceiverUpdated__Params {
    return new ProtocolFeeReceiverUpdated__Params(this);
  }
}

export class ProtocolFeeReceiverUpdated__Params {
  _event: ProtocolFeeReceiverUpdated;

  constructor(event: ProtocolFeeReceiverUpdated) {
    this._event = event;
  }

  get protocolFeeReceiver(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class ProtocolFeeUpdated extends ethereum.Event {
  get params(): ProtocolFeeUpdated__Params {
    return new ProtocolFeeUpdated__Params(this);
  }
}

export class ProtocolFeeUpdated__Params {
  _event: ProtocolFeeUpdated;

  constructor(event: ProtocolFeeUpdated) {
    this._event = event;
  }

  get protocolFee(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class Repay extends ethereum.Event {
  get params(): Repay__Params {
    return new Repay__Params(this);
  }
}

export class Repay__Params {
  _event: Repay;

  constructor(event: Repay) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get underlyingToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get recipient(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get credit(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class RepayLimitUpdated extends ethereum.Event {
  get params(): RepayLimitUpdated__Params {
    return new RepayLimitUpdated__Params(this);
  }
}

export class RepayLimitUpdated__Params {
  _event: RepayLimitUpdated;

  constructor(event: RepayLimitUpdated) {
    this._event = event;
  }

  get underlyingToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get maximum(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get blocks(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class SentinelSet extends ethereum.Event {
  get params(): SentinelSet__Params {
    return new SentinelSet__Params(this);
  }
}

export class SentinelSet__Params {
  _event: SentinelSet;

  constructor(event: SentinelSet) {
    this._event = event;
  }

  get sentinel(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get flag(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class Snap extends ethereum.Event {
  get params(): Snap__Params {
    return new Snap__Params(this);
  }
}

export class Snap__Params {
  _event: Snap;

  constructor(event: Snap) {
    this._event = event;
  }

  get yieldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get expectedValue(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class SweepRewardTokens extends ethereum.Event {
  get params(): SweepRewardTokens__Params {
    return new SweepRewardTokens__Params(this);
  }
}

export class SweepRewardTokens__Params {
  _event: SweepRewardTokens;

  constructor(event: SweepRewardTokens) {
    this._event = event;
  }

  get rewardToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class SweepTokens extends ethereum.Event {
  get params(): SweepTokens__Params {
    return new SweepTokens__Params(this);
  }
}

export class SweepTokens__Params {
  _event: SweepTokens;

  constructor(event: SweepTokens) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class TokenAdapterUpdated extends ethereum.Event {
  get params(): TokenAdapterUpdated__Params {
    return new TokenAdapterUpdated__Params(this);
  }
}

export class TokenAdapterUpdated__Params {
  _event: TokenAdapterUpdated;

  constructor(event: TokenAdapterUpdated) {
    this._event = event;
  }

  get yieldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get tokenAdapter(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class TransmuterUpdated extends ethereum.Event {
  get params(): TransmuterUpdated__Params {
    return new TransmuterUpdated__Params(this);
  }
}

export class TransmuterUpdated__Params {
  _event: TransmuterUpdated;

  constructor(event: TransmuterUpdated) {
    this._event = event;
  }

  get transmuter(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class UnderlyingTokenEnabled extends ethereum.Event {
  get params(): UnderlyingTokenEnabled__Params {
    return new UnderlyingTokenEnabled__Params(this);
  }
}

export class UnderlyingTokenEnabled__Params {
  _event: UnderlyingTokenEnabled;

  constructor(event: UnderlyingTokenEnabled) {
    this._event = event;
  }

  get underlyingToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class Withdraw extends ethereum.Event {
  get params(): Withdraw__Params {
    return new Withdraw__Params(this);
  }
}

export class Withdraw__Params {
  _event: Withdraw;

  constructor(event: Withdraw) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get yieldToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get shares(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get recipient(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class YieldTokenEnabled extends ethereum.Event {
  get params(): YieldTokenEnabled__Params {
    return new YieldTokenEnabled__Params(this);
  }
}

export class YieldTokenEnabled__Params {
  _event: YieldTokenEnabled;

  constructor(event: YieldTokenEnabled) {
    this._event = event;
  }

  get yieldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class AlchemistV2Impl__accountsResult {
  value0: BigInt;
  value1: Array<Address>;

  constructor(value0: BigInt, value1: Array<Address>) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromSignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromAddressArray(this.value1));
    return map;
  }

  getDebt(): BigInt {
    return this.value0;
  }

  getDepositedTokens(): Array<Address> {
    return this.value1;
  }
}

export class AlchemistV2Impl__getLiquidationLimitInfoResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getCurrentLimit(): BigInt {
    return this.value0;
  }

  getRate(): BigInt {
    return this.value1;
  }

  getMaximum(): BigInt {
    return this.value2;
  }
}

export class AlchemistV2Impl__getMintLimitInfoResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getCurrentLimit(): BigInt {
    return this.value0;
  }

  getRate(): BigInt {
    return this.value1;
  }

  getMaximum(): BigInt {
    return this.value2;
  }
}

export class AlchemistV2Impl__getRepayLimitInfoResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getCurrentLimit(): BigInt {
    return this.value0;
  }

  getRate(): BigInt {
    return this.value1;
  }

  getMaximum(): BigInt {
    return this.value2;
  }
}

export class AlchemistV2Impl__getUnderlyingTokenParametersResultValue0Struct extends ethereum.Tuple {
  get decimals(): i32 {
    return this[0].toI32();
  }

  get conversionFactor(): BigInt {
    return this[1].toBigInt();
  }

  get enabled(): boolean {
    return this[2].toBoolean();
  }
}

export class AlchemistV2Impl__getYieldTokenParametersResultValue0Struct extends ethereum.Tuple {
  get decimals(): i32 {
    return this[0].toI32();
  }

  get underlyingToken(): Address {
    return this[1].toAddress();
  }

  get adapter(): Address {
    return this[2].toAddress();
  }

  get maximumLoss(): BigInt {
    return this[3].toBigInt();
  }

  get maximumExpectedValue(): BigInt {
    return this[4].toBigInt();
  }

  get creditUnlockRate(): BigInt {
    return this[5].toBigInt();
  }

  get activeBalance(): BigInt {
    return this[6].toBigInt();
  }

  get harvestableBalance(): BigInt {
    return this[7].toBigInt();
  }

  get totalShares(): BigInt {
    return this[8].toBigInt();
  }

  get expectedValue(): BigInt {
    return this[9].toBigInt();
  }

  get pendingCredit(): BigInt {
    return this[10].toBigInt();
  }

  get distributedCredit(): BigInt {
    return this[11].toBigInt();
  }

  get lastDistributionBlock(): BigInt {
    return this[12].toBigInt();
  }

  get accruedWeight(): BigInt {
    return this[13].toBigInt();
  }

  get enabled(): boolean {
    return this[14].toBoolean();
  }
}

export class AlchemistV2Impl__positionsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getShares(): BigInt {
    return this.value0;
  }

  getLastAccruedWeight(): BigInt {
    return this.value1;
  }
}

export class AlchemistV2Impl extends ethereum.SmartContract {
  static bind(address: Address): AlchemistV2Impl {
    return new AlchemistV2Impl("AlchemistV2Impl", address);
  }

  BPS(): BigInt {
    let result = super.call("BPS", "BPS():(uint256)", []);

    return result[0].toBigInt();
  }

  try_BPS(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("BPS", "BPS():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  FIXED_POINT_SCALAR(): BigInt {
    let result = super.call(
      "FIXED_POINT_SCALAR",
      "FIXED_POINT_SCALAR():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_FIXED_POINT_SCALAR(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "FIXED_POINT_SCALAR",
      "FIXED_POINT_SCALAR():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  accounts(owner: Address): AlchemistV2Impl__accountsResult {
    let result = super.call(
      "accounts",
      "accounts(address):(int256,address[])",
      [ethereum.Value.fromAddress(owner)],
    );

    return new AlchemistV2Impl__accountsResult(
      result[0].toBigInt(),
      result[1].toAddressArray(),
    );
  }

  try_accounts(
    owner: Address,
  ): ethereum.CallResult<AlchemistV2Impl__accountsResult> {
    let result = super.tryCall(
      "accounts",
      "accounts(address):(int256,address[])",
      [ethereum.Value.fromAddress(owner)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AlchemistV2Impl__accountsResult(
        value[0].toBigInt(),
        value[1].toAddressArray(),
      ),
    );
  }

  admin(): Address {
    let result = super.call("admin", "admin():(address)", []);

    return result[0].toAddress();
  }

  try_admin(): ethereum.CallResult<Address> {
    let result = super.tryCall("admin", "admin():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  burn(amount: BigInt, recipient: Address): BigInt {
    let result = super.call("burn", "burn(uint256,address):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount),
      ethereum.Value.fromAddress(recipient),
    ]);

    return result[0].toBigInt();
  }

  try_burn(amount: BigInt, recipient: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("burn", "burn(uint256,address):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount),
      ethereum.Value.fromAddress(recipient),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertSharesToUnderlyingTokens(yieldToken: Address, shares: BigInt): BigInt {
    let result = super.call(
      "convertSharesToUnderlyingTokens",
      "convertSharesToUnderlyingTokens(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
      ],
    );

    return result[0].toBigInt();
  }

  try_convertSharesToUnderlyingTokens(
    yieldToken: Address,
    shares: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertSharesToUnderlyingTokens",
      "convertSharesToUnderlyingTokens(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertSharesToYieldTokens(yieldToken: Address, shares: BigInt): BigInt {
    let result = super.call(
      "convertSharesToYieldTokens",
      "convertSharesToYieldTokens(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
      ],
    );

    return result[0].toBigInt();
  }

  try_convertSharesToYieldTokens(
    yieldToken: Address,
    shares: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertSharesToYieldTokens",
      "convertSharesToYieldTokens(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertUnderlyingTokensToShares(yieldToken: Address, amount: BigInt): BigInt {
    let result = super.call(
      "convertUnderlyingTokensToShares",
      "convertUnderlyingTokensToShares(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBigInt();
  }

  try_convertUnderlyingTokensToShares(
    yieldToken: Address,
    amount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertUnderlyingTokensToShares",
      "convertUnderlyingTokensToShares(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertUnderlyingTokensToYield(yieldToken: Address, amount: BigInt): BigInt {
    let result = super.call(
      "convertUnderlyingTokensToYield",
      "convertUnderlyingTokensToYield(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBigInt();
  }

  try_convertUnderlyingTokensToYield(
    yieldToken: Address,
    amount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertUnderlyingTokensToYield",
      "convertUnderlyingTokensToYield(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertYieldTokensToShares(yieldToken: Address, amount: BigInt): BigInt {
    let result = super.call(
      "convertYieldTokensToShares",
      "convertYieldTokensToShares(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBigInt();
  }

  try_convertYieldTokensToShares(
    yieldToken: Address,
    amount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertYieldTokensToShares",
      "convertYieldTokensToShares(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertYieldTokensToUnderlying(yieldToken: Address, amount: BigInt): BigInt {
    let result = super.call(
      "convertYieldTokensToUnderlying",
      "convertYieldTokensToUnderlying(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBigInt();
  }

  try_convertYieldTokensToUnderlying(
    yieldToken: Address,
    amount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertYieldTokensToUnderlying",
      "convertYieldTokensToUnderlying(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  debtToken(): Address {
    let result = super.call("debtToken", "debtToken():(address)", []);

    return result[0].toAddress();
  }

  try_debtToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("debtToken", "debtToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  deposit(yieldToken: Address, amount: BigInt, recipient: Address): BigInt {
    let result = super.call(
      "deposit",
      "deposit(address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(recipient),
      ],
    );

    return result[0].toBigInt();
  }

  try_deposit(
    yieldToken: Address,
    amount: BigInt,
    recipient: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "deposit",
      "deposit(address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(recipient),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  depositUnderlying(
    yieldToken: Address,
    amount: BigInt,
    recipient: Address,
    minimumAmountOut: BigInt,
  ): BigInt {
    let result = super.call(
      "depositUnderlying",
      "depositUnderlying(address,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(minimumAmountOut),
      ],
    );

    return result[0].toBigInt();
  }

  try_depositUnderlying(
    yieldToken: Address,
    amount: BigInt,
    recipient: Address,
    minimumAmountOut: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "depositUnderlying",
      "depositUnderlying(address,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(minimumAmountOut),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLiquidationLimitInfo(
    underlyingToken: Address,
  ): AlchemistV2Impl__getLiquidationLimitInfoResult {
    let result = super.call(
      "getLiquidationLimitInfo",
      "getLiquidationLimitInfo(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(underlyingToken)],
    );

    return new AlchemistV2Impl__getLiquidationLimitInfoResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
    );
  }

  try_getLiquidationLimitInfo(
    underlyingToken: Address,
  ): ethereum.CallResult<AlchemistV2Impl__getLiquidationLimitInfoResult> {
    let result = super.tryCall(
      "getLiquidationLimitInfo",
      "getLiquidationLimitInfo(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(underlyingToken)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AlchemistV2Impl__getLiquidationLimitInfoResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
      ),
    );
  }

  getMintLimitInfo(): AlchemistV2Impl__getMintLimitInfoResult {
    let result = super.call(
      "getMintLimitInfo",
      "getMintLimitInfo():(uint256,uint256,uint256)",
      [],
    );

    return new AlchemistV2Impl__getMintLimitInfoResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
    );
  }

  try_getMintLimitInfo(): ethereum.CallResult<AlchemistV2Impl__getMintLimitInfoResult> {
    let result = super.tryCall(
      "getMintLimitInfo",
      "getMintLimitInfo():(uint256,uint256,uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AlchemistV2Impl__getMintLimitInfoResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
      ),
    );
  }

  getRepayLimitInfo(
    underlyingToken: Address,
  ): AlchemistV2Impl__getRepayLimitInfoResult {
    let result = super.call(
      "getRepayLimitInfo",
      "getRepayLimitInfo(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(underlyingToken)],
    );

    return new AlchemistV2Impl__getRepayLimitInfoResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
    );
  }

  try_getRepayLimitInfo(
    underlyingToken: Address,
  ): ethereum.CallResult<AlchemistV2Impl__getRepayLimitInfoResult> {
    let result = super.tryCall(
      "getRepayLimitInfo",
      "getRepayLimitInfo(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(underlyingToken)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AlchemistV2Impl__getRepayLimitInfoResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
      ),
    );
  }

  getSupportedUnderlyingTokens(): Array<Address> {
    let result = super.call(
      "getSupportedUnderlyingTokens",
      "getSupportedUnderlyingTokens():(address[])",
      [],
    );

    return result[0].toAddressArray();
  }

  try_getSupportedUnderlyingTokens(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "getSupportedUnderlyingTokens",
      "getSupportedUnderlyingTokens():(address[])",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getSupportedYieldTokens(): Array<Address> {
    let result = super.call(
      "getSupportedYieldTokens",
      "getSupportedYieldTokens():(address[])",
      [],
    );

    return result[0].toAddressArray();
  }

  try_getSupportedYieldTokens(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "getSupportedYieldTokens",
      "getSupportedYieldTokens():(address[])",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getUnderlyingTokenParameters(
    underlyingToken: Address,
  ): AlchemistV2Impl__getUnderlyingTokenParametersResultValue0Struct {
    let result = super.call(
      "getUnderlyingTokenParameters",
      "getUnderlyingTokenParameters(address):((uint8,uint256,bool))",
      [ethereum.Value.fromAddress(underlyingToken)],
    );

    return changetype<AlchemistV2Impl__getUnderlyingTokenParametersResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_getUnderlyingTokenParameters(
    underlyingToken: Address,
  ): ethereum.CallResult<AlchemistV2Impl__getUnderlyingTokenParametersResultValue0Struct> {
    let result = super.tryCall(
      "getUnderlyingTokenParameters",
      "getUnderlyingTokenParameters(address):((uint8,uint256,bool))",
      [ethereum.Value.fromAddress(underlyingToken)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<AlchemistV2Impl__getUnderlyingTokenParametersResultValue0Struct>(
        value[0].toTuple(),
      ),
    );
  }

  getUnderlyingTokensPerShare(yieldToken: Address): BigInt {
    let result = super.call(
      "getUnderlyingTokensPerShare",
      "getUnderlyingTokensPerShare(address):(uint256)",
      [ethereum.Value.fromAddress(yieldToken)],
    );

    return result[0].toBigInt();
  }

  try_getUnderlyingTokensPerShare(
    yieldToken: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getUnderlyingTokensPerShare",
      "getUnderlyingTokensPerShare(address):(uint256)",
      [ethereum.Value.fromAddress(yieldToken)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getYieldTokenParameters(
    yieldToken: Address,
  ): AlchemistV2Impl__getYieldTokenParametersResultValue0Struct {
    let result = super.call(
      "getYieldTokenParameters",
      "getYieldTokenParameters(address):((uint8,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool))",
      [ethereum.Value.fromAddress(yieldToken)],
    );

    return changetype<AlchemistV2Impl__getYieldTokenParametersResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_getYieldTokenParameters(
    yieldToken: Address,
  ): ethereum.CallResult<AlchemistV2Impl__getYieldTokenParametersResultValue0Struct> {
    let result = super.tryCall(
      "getYieldTokenParameters",
      "getYieldTokenParameters(address):((uint8,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool))",
      [ethereum.Value.fromAddress(yieldToken)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<AlchemistV2Impl__getYieldTokenParametersResultValue0Struct>(
        value[0].toTuple(),
      ),
    );
  }

  getYieldTokensPerShare(yieldToken: Address): BigInt {
    let result = super.call(
      "getYieldTokensPerShare",
      "getYieldTokensPerShare(address):(uint256)",
      [ethereum.Value.fromAddress(yieldToken)],
    );

    return result[0].toBigInt();
  }

  try_getYieldTokensPerShare(yieldToken: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getYieldTokensPerShare",
      "getYieldTokensPerShare(address):(uint256)",
      [ethereum.Value.fromAddress(yieldToken)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isSupportedUnderlyingToken(underlyingToken: Address): boolean {
    let result = super.call(
      "isSupportedUnderlyingToken",
      "isSupportedUnderlyingToken(address):(bool)",
      [ethereum.Value.fromAddress(underlyingToken)],
    );

    return result[0].toBoolean();
  }

  try_isSupportedUnderlyingToken(
    underlyingToken: Address,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isSupportedUnderlyingToken",
      "isSupportedUnderlyingToken(address):(bool)",
      [ethereum.Value.fromAddress(underlyingToken)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSupportedYieldToken(yieldToken: Address): boolean {
    let result = super.call(
      "isSupportedYieldToken",
      "isSupportedYieldToken(address):(bool)",
      [ethereum.Value.fromAddress(yieldToken)],
    );

    return result[0].toBoolean();
  }

  try_isSupportedYieldToken(yieldToken: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isSupportedYieldToken",
      "isSupportedYieldToken(address):(bool)",
      [ethereum.Value.fromAddress(yieldToken)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  keepers(param0: Address): boolean {
    let result = super.call("keepers", "keepers(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBoolean();
  }

  try_keepers(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("keepers", "keepers(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  liquidate(
    yieldToken: Address,
    shares: BigInt,
    minimumAmountOut: BigInt,
  ): BigInt {
    let result = super.call(
      "liquidate",
      "liquidate(address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromUnsignedBigInt(minimumAmountOut),
      ],
    );

    return result[0].toBigInt();
  }

  try_liquidate(
    yieldToken: Address,
    shares: BigInt,
    minimumAmountOut: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "liquidate",
      "liquidate(address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromUnsignedBigInt(minimumAmountOut),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minimumCollateralization(): BigInt {
    let result = super.call(
      "minimumCollateralization",
      "minimumCollateralization():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_minimumCollateralization(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minimumCollateralization",
      "minimumCollateralization():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  mintAllowance(owner: Address, spender: Address): BigInt {
    let result = super.call(
      "mintAllowance",
      "mintAllowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );

    return result[0].toBigInt();
  }

  try_mintAllowance(
    owner: Address,
    spender: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "mintAllowance",
      "mintAllowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  normalizeDebtTokensToUnderlying(
    underlyingToken: Address,
    amount: BigInt,
  ): BigInt {
    let result = super.call(
      "normalizeDebtTokensToUnderlying",
      "normalizeDebtTokensToUnderlying(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(underlyingToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBigInt();
  }

  try_normalizeDebtTokensToUnderlying(
    underlyingToken: Address,
    amount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "normalizeDebtTokensToUnderlying",
      "normalizeDebtTokensToUnderlying(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(underlyingToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  normalizeUnderlyingTokensToDebt(
    underlyingToken: Address,
    amount: BigInt,
  ): BigInt {
    let result = super.call(
      "normalizeUnderlyingTokensToDebt",
      "normalizeUnderlyingTokensToDebt(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(underlyingToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBigInt();
  }

  try_normalizeUnderlyingTokensToDebt(
    underlyingToken: Address,
    amount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "normalizeUnderlyingTokensToDebt",
      "normalizeUnderlyingTokensToDebt(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(underlyingToken),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  pendingAdmin(): Address {
    let result = super.call("pendingAdmin", "pendingAdmin():(address)", []);

    return result[0].toAddress();
  }

  try_pendingAdmin(): ethereum.CallResult<Address> {
    let result = super.tryCall("pendingAdmin", "pendingAdmin():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  positions(
    owner: Address,
    yieldToken: Address,
  ): AlchemistV2Impl__positionsResult {
    let result = super.call(
      "positions",
      "positions(address,address):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(yieldToken),
      ],
    );

    return new AlchemistV2Impl__positionsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
    );
  }

  try_positions(
    owner: Address,
    yieldToken: Address,
  ): ethereum.CallResult<AlchemistV2Impl__positionsResult> {
    let result = super.tryCall(
      "positions",
      "positions(address,address):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(yieldToken),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AlchemistV2Impl__positionsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
      ),
    );
  }

  protocolFee(): BigInt {
    let result = super.call("protocolFee", "protocolFee():(uint256)", []);

    return result[0].toBigInt();
  }

  try_protocolFee(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("protocolFee", "protocolFee():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  protocolFeeReceiver(): Address {
    let result = super.call(
      "protocolFeeReceiver",
      "protocolFeeReceiver():(address)",
      [],
    );

    return result[0].toAddress();
  }

  try_protocolFeeReceiver(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "protocolFeeReceiver",
      "protocolFeeReceiver():(address)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  repay(underlyingToken: Address, amount: BigInt, recipient: Address): BigInt {
    let result = super.call(
      "repay",
      "repay(address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(underlyingToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(recipient),
      ],
    );

    return result[0].toBigInt();
  }

  try_repay(
    underlyingToken: Address,
    amount: BigInt,
    recipient: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "repay",
      "repay(address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(underlyingToken),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromAddress(recipient),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  sentinels(param0: Address): boolean {
    let result = super.call("sentinels", "sentinels(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBoolean();
  }

  try_sentinels(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("sentinels", "sentinels(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  totalValue(owner: Address): BigInt {
    let result = super.call("totalValue", "totalValue(address):(uint256)", [
      ethereum.Value.fromAddress(owner),
    ]);

    return result[0].toBigInt();
  }

  try_totalValue(owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalValue", "totalValue(address):(uint256)", [
      ethereum.Value.fromAddress(owner),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transferAdapter(): Address {
    let result = super.call(
      "transferAdapter",
      "transferAdapter():(address)",
      [],
    );

    return result[0].toAddress();
  }

  try_transferAdapter(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "transferAdapter",
      "transferAdapter():(address)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  transmuter(): Address {
    let result = super.call("transmuter", "transmuter():(address)", []);

    return result[0].toAddress();
  }

  try_transmuter(): ethereum.CallResult<Address> {
    let result = super.tryCall("transmuter", "transmuter():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  version(): string {
    let result = super.call("version", "version():(string)", []);

    return result[0].toString();
  }

  try_version(): ethereum.CallResult<string> {
    let result = super.tryCall("version", "version():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  whitelist(): Address {
    let result = super.call("whitelist", "whitelist():(address)", []);

    return result[0].toAddress();
  }

  try_whitelist(): ethereum.CallResult<Address> {
    let result = super.tryCall("whitelist", "whitelist():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  withdraw(yieldToken: Address, shares: BigInt, recipient: Address): BigInt {
    let result = super.call(
      "withdraw",
      "withdraw(address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(recipient),
      ],
    );

    return result[0].toBigInt();
  }

  try_withdraw(
    yieldToken: Address,
    shares: BigInt,
    recipient: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdraw",
      "withdraw(address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(recipient),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  withdrawAllowance(
    owner: Address,
    spender: Address,
    yieldToken: Address,
  ): BigInt {
    let result = super.call(
      "withdrawAllowance",
      "withdrawAllowance(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromAddress(yieldToken),
      ],
    );

    return result[0].toBigInt();
  }

  try_withdrawAllowance(
    owner: Address,
    spender: Address,
    yieldToken: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdrawAllowance",
      "withdrawAllowance(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromAddress(yieldToken),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  withdrawFrom(
    owner: Address,
    yieldToken: Address,
    shares: BigInt,
    recipient: Address,
  ): BigInt {
    let result = super.call(
      "withdrawFrom",
      "withdrawFrom(address,address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(recipient),
      ],
    );

    return result[0].toBigInt();
  }

  try_withdrawFrom(
    owner: Address,
    yieldToken: Address,
    shares: BigInt,
    recipient: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdrawFrom",
      "withdrawFrom(address,address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(recipient),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  withdrawUnderlying(
    yieldToken: Address,
    shares: BigInt,
    recipient: Address,
    minimumAmountOut: BigInt,
  ): BigInt {
    let result = super.call(
      "withdrawUnderlying",
      "withdrawUnderlying(address,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(minimumAmountOut),
      ],
    );

    return result[0].toBigInt();
  }

  try_withdrawUnderlying(
    yieldToken: Address,
    shares: BigInt,
    recipient: Address,
    minimumAmountOut: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdrawUnderlying",
      "withdrawUnderlying(address,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(minimumAmountOut),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  withdrawUnderlyingFrom(
    owner: Address,
    yieldToken: Address,
    shares: BigInt,
    recipient: Address,
    minimumAmountOut: BigInt,
  ): BigInt {
    let result = super.call(
      "withdrawUnderlyingFrom",
      "withdrawUnderlyingFrom(address,address,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(minimumAmountOut),
      ],
    );

    return result[0].toBigInt();
  }

  try_withdrawUnderlyingFrom(
    owner: Address,
    yieldToken: Address,
    shares: BigInt,
    recipient: Address,
    minimumAmountOut: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdrawUnderlyingFrom",
      "withdrawUnderlyingFrom(address,address,uint256,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(yieldToken),
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(minimumAmountOut),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AcceptAdminCall extends ethereum.Call {
  get inputs(): AcceptAdminCall__Inputs {
    return new AcceptAdminCall__Inputs(this);
  }

  get outputs(): AcceptAdminCall__Outputs {
    return new AcceptAdminCall__Outputs(this);
  }
}

export class AcceptAdminCall__Inputs {
  _call: AcceptAdminCall;

  constructor(call: AcceptAdminCall) {
    this._call = call;
  }
}

export class AcceptAdminCall__Outputs {
  _call: AcceptAdminCall;

  constructor(call: AcceptAdminCall) {
    this._call = call;
  }
}

export class AddUnderlyingTokenCall extends ethereum.Call {
  get inputs(): AddUnderlyingTokenCall__Inputs {
    return new AddUnderlyingTokenCall__Inputs(this);
  }

  get outputs(): AddUnderlyingTokenCall__Outputs {
    return new AddUnderlyingTokenCall__Outputs(this);
  }
}

export class AddUnderlyingTokenCall__Inputs {
  _call: AddUnderlyingTokenCall;

  constructor(call: AddUnderlyingTokenCall) {
    this._call = call;
  }

  get underlyingToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get config(): AddUnderlyingTokenCallConfigStruct {
    return changetype<AddUnderlyingTokenCallConfigStruct>(
      this._call.inputValues[1].value.toTuple(),
    );
  }
}

export class AddUnderlyingTokenCall__Outputs {
  _call: AddUnderlyingTokenCall;

  constructor(call: AddUnderlyingTokenCall) {
    this._call = call;
  }
}

export class AddUnderlyingTokenCallConfigStruct extends ethereum.Tuple {
  get repayLimitMinimum(): BigInt {
    return this[0].toBigInt();
  }

  get repayLimitMaximum(): BigInt {
    return this[1].toBigInt();
  }

  get repayLimitBlocks(): BigInt {
    return this[2].toBigInt();
  }

  get liquidationLimitMinimum(): BigInt {
    return this[3].toBigInt();
  }

  get liquidationLimitMaximum(): BigInt {
    return this[4].toBigInt();
  }

  get liquidationLimitBlocks(): BigInt {
    return this[5].toBigInt();
  }
}

export class AddYieldTokenCall extends ethereum.Call {
  get inputs(): AddYieldTokenCall__Inputs {
    return new AddYieldTokenCall__Inputs(this);
  }

  get outputs(): AddYieldTokenCall__Outputs {
    return new AddYieldTokenCall__Outputs(this);
  }
}

export class AddYieldTokenCall__Inputs {
  _call: AddYieldTokenCall;

  constructor(call: AddYieldTokenCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get config(): AddYieldTokenCallConfigStruct {
    return changetype<AddYieldTokenCallConfigStruct>(
      this._call.inputValues[1].value.toTuple(),
    );
  }
}

export class AddYieldTokenCall__Outputs {
  _call: AddYieldTokenCall;

  constructor(call: AddYieldTokenCall) {
    this._call = call;
  }
}

export class AddYieldTokenCallConfigStruct extends ethereum.Tuple {
  get adapter(): Address {
    return this[0].toAddress();
  }

  get maximumLoss(): BigInt {
    return this[1].toBigInt();
  }

  get maximumExpectedValue(): BigInt {
    return this[2].toBigInt();
  }

  get creditUnlockBlocks(): BigInt {
    return this[3].toBigInt();
  }
}

export class ApproveMintCall extends ethereum.Call {
  get inputs(): ApproveMintCall__Inputs {
    return new ApproveMintCall__Inputs(this);
  }

  get outputs(): ApproveMintCall__Outputs {
    return new ApproveMintCall__Outputs(this);
  }
}

export class ApproveMintCall__Inputs {
  _call: ApproveMintCall;

  constructor(call: ApproveMintCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveMintCall__Outputs {
  _call: ApproveMintCall;

  constructor(call: ApproveMintCall) {
    this._call = call;
  }
}

export class ApproveWithdrawCall extends ethereum.Call {
  get inputs(): ApproveWithdrawCall__Inputs {
    return new ApproveWithdrawCall__Inputs(this);
  }

  get outputs(): ApproveWithdrawCall__Outputs {
    return new ApproveWithdrawCall__Outputs(this);
  }
}

export class ApproveWithdrawCall__Inputs {
  _call: ApproveWithdrawCall;

  constructor(call: ApproveWithdrawCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get yieldToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get shares(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ApproveWithdrawCall__Outputs {
  _call: ApproveWithdrawCall;

  constructor(call: ApproveWithdrawCall) {
    this._call = call;
  }
}

export class BurnCall extends ethereum.Call {
  get inputs(): BurnCall__Inputs {
    return new BurnCall__Inputs(this);
  }

  get outputs(): BurnCall__Outputs {
    return new BurnCall__Outputs(this);
  }
}

export class BurnCall__Inputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class BurnCall__Outputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ConfigureCreditUnlockRateCall extends ethereum.Call {
  get inputs(): ConfigureCreditUnlockRateCall__Inputs {
    return new ConfigureCreditUnlockRateCall__Inputs(this);
  }

  get outputs(): ConfigureCreditUnlockRateCall__Outputs {
    return new ConfigureCreditUnlockRateCall__Outputs(this);
  }
}

export class ConfigureCreditUnlockRateCall__Inputs {
  _call: ConfigureCreditUnlockRateCall;

  constructor(call: ConfigureCreditUnlockRateCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get blocks(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ConfigureCreditUnlockRateCall__Outputs {
  _call: ConfigureCreditUnlockRateCall;

  constructor(call: ConfigureCreditUnlockRateCall) {
    this._call = call;
  }
}

export class ConfigureLiquidationLimitCall extends ethereum.Call {
  get inputs(): ConfigureLiquidationLimitCall__Inputs {
    return new ConfigureLiquidationLimitCall__Inputs(this);
  }

  get outputs(): ConfigureLiquidationLimitCall__Outputs {
    return new ConfigureLiquidationLimitCall__Outputs(this);
  }
}

export class ConfigureLiquidationLimitCall__Inputs {
  _call: ConfigureLiquidationLimitCall;

  constructor(call: ConfigureLiquidationLimitCall) {
    this._call = call;
  }

  get underlyingToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get maximum(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get blocks(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ConfigureLiquidationLimitCall__Outputs {
  _call: ConfigureLiquidationLimitCall;

  constructor(call: ConfigureLiquidationLimitCall) {
    this._call = call;
  }
}

export class ConfigureMintingLimitCall extends ethereum.Call {
  get inputs(): ConfigureMintingLimitCall__Inputs {
    return new ConfigureMintingLimitCall__Inputs(this);
  }

  get outputs(): ConfigureMintingLimitCall__Outputs {
    return new ConfigureMintingLimitCall__Outputs(this);
  }
}

export class ConfigureMintingLimitCall__Inputs {
  _call: ConfigureMintingLimitCall;

  constructor(call: ConfigureMintingLimitCall) {
    this._call = call;
  }

  get maximum(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get rate(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ConfigureMintingLimitCall__Outputs {
  _call: ConfigureMintingLimitCall;

  constructor(call: ConfigureMintingLimitCall) {
    this._call = call;
  }
}

export class ConfigureRepayLimitCall extends ethereum.Call {
  get inputs(): ConfigureRepayLimitCall__Inputs {
    return new ConfigureRepayLimitCall__Inputs(this);
  }

  get outputs(): ConfigureRepayLimitCall__Outputs {
    return new ConfigureRepayLimitCall__Outputs(this);
  }
}

export class ConfigureRepayLimitCall__Inputs {
  _call: ConfigureRepayLimitCall;

  constructor(call: ConfigureRepayLimitCall) {
    this._call = call;
  }

  get underlyingToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get maximum(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get blocks(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ConfigureRepayLimitCall__Outputs {
  _call: ConfigureRepayLimitCall;

  constructor(call: ConfigureRepayLimitCall) {
    this._call = call;
  }
}

export class DepositCall extends ethereum.Call {
  get inputs(): DepositCall__Inputs {
    return new DepositCall__Inputs(this);
  }

  get outputs(): DepositCall__Outputs {
    return new DepositCall__Outputs(this);
  }
}

export class DepositCall__Inputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class DepositCall__Outputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class DepositUnderlyingCall extends ethereum.Call {
  get inputs(): DepositUnderlyingCall__Inputs {
    return new DepositUnderlyingCall__Inputs(this);
  }

  get outputs(): DepositUnderlyingCall__Outputs {
    return new DepositUnderlyingCall__Outputs(this);
  }
}

export class DepositUnderlyingCall__Inputs {
  _call: DepositUnderlyingCall;

  constructor(call: DepositUnderlyingCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get minimumAmountOut(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class DepositUnderlyingCall__Outputs {
  _call: DepositUnderlyingCall;

  constructor(call: DepositUnderlyingCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class DonateCall extends ethereum.Call {
  get inputs(): DonateCall__Inputs {
    return new DonateCall__Inputs(this);
  }

  get outputs(): DonateCall__Outputs {
    return new DonateCall__Outputs(this);
  }
}

export class DonateCall__Inputs {
  _call: DonateCall;

  constructor(call: DonateCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class DonateCall__Outputs {
  _call: DonateCall;

  constructor(call: DonateCall) {
    this._call = call;
  }
}

export class HarvestCall extends ethereum.Call {
  get inputs(): HarvestCall__Inputs {
    return new HarvestCall__Inputs(this);
  }

  get outputs(): HarvestCall__Outputs {
    return new HarvestCall__Outputs(this);
  }
}

export class HarvestCall__Inputs {
  _call: HarvestCall;

  constructor(call: HarvestCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get minimumAmountOut(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class HarvestCall__Outputs {
  _call: HarvestCall;

  constructor(call: HarvestCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get params(): InitializeCallParamsStruct {
    return changetype<InitializeCallParamsStruct>(
      this._call.inputValues[0].value.toTuple(),
    );
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class InitializeCallParamsStruct extends ethereum.Tuple {
  get admin(): Address {
    return this[0].toAddress();
  }

  get debtToken(): Address {
    return this[1].toAddress();
  }

  get transmuter(): Address {
    return this[2].toAddress();
  }

  get minimumCollateralization(): BigInt {
    return this[3].toBigInt();
  }

  get protocolFee(): BigInt {
    return this[4].toBigInt();
  }

  get protocolFeeReceiver(): Address {
    return this[5].toAddress();
  }

  get mintingLimitMinimum(): BigInt {
    return this[6].toBigInt();
  }

  get mintingLimitMaximum(): BigInt {
    return this[7].toBigInt();
  }

  get mintingLimitBlocks(): BigInt {
    return this[8].toBigInt();
  }

  get whitelist(): Address {
    return this[9].toAddress();
  }
}

export class LiquidateCall extends ethereum.Call {
  get inputs(): LiquidateCall__Inputs {
    return new LiquidateCall__Inputs(this);
  }

  get outputs(): LiquidateCall__Outputs {
    return new LiquidateCall__Outputs(this);
  }
}

export class LiquidateCall__Inputs {
  _call: LiquidateCall;

  constructor(call: LiquidateCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get shares(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get minimumAmountOut(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class LiquidateCall__Outputs {
  _call: LiquidateCall;

  constructor(call: LiquidateCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this);
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this);
  }
}

export class MintCall__Inputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class MintCall__Outputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }
}

export class MintFromCall extends ethereum.Call {
  get inputs(): MintFromCall__Inputs {
    return new MintFromCall__Inputs(this);
  }

  get outputs(): MintFromCall__Outputs {
    return new MintFromCall__Outputs(this);
  }
}

export class MintFromCall__Inputs {
  _call: MintFromCall;

  constructor(call: MintFromCall) {
    this._call = call;
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class MintFromCall__Outputs {
  _call: MintFromCall;

  constructor(call: MintFromCall) {
    this._call = call;
  }
}

export class MulticallCall extends ethereum.Call {
  get inputs(): MulticallCall__Inputs {
    return new MulticallCall__Inputs(this);
  }

  get outputs(): MulticallCall__Outputs {
    return new MulticallCall__Outputs(this);
  }
}

export class MulticallCall__Inputs {
  _call: MulticallCall;

  constructor(call: MulticallCall) {
    this._call = call;
  }

  get data(): Array<Bytes> {
    return this._call.inputValues[0].value.toBytesArray();
  }
}

export class MulticallCall__Outputs {
  _call: MulticallCall;

  constructor(call: MulticallCall) {
    this._call = call;
  }

  get results(): Array<Bytes> {
    return this._call.outputValues[0].value.toBytesArray();
  }
}

export class PokeCall extends ethereum.Call {
  get inputs(): PokeCall__Inputs {
    return new PokeCall__Inputs(this);
  }

  get outputs(): PokeCall__Outputs {
    return new PokeCall__Outputs(this);
  }
}

export class PokeCall__Inputs {
  _call: PokeCall;

  constructor(call: PokeCall) {
    this._call = call;
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class PokeCall__Outputs {
  _call: PokeCall;

  constructor(call: PokeCall) {
    this._call = call;
  }
}

export class RepayCall extends ethereum.Call {
  get inputs(): RepayCall__Inputs {
    return new RepayCall__Inputs(this);
  }

  get outputs(): RepayCall__Outputs {
    return new RepayCall__Outputs(this);
  }
}

export class RepayCall__Inputs {
  _call: RepayCall;

  constructor(call: RepayCall) {
    this._call = call;
  }

  get underlyingToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class RepayCall__Outputs {
  _call: RepayCall;

  constructor(call: RepayCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetKeeperCall extends ethereum.Call {
  get inputs(): SetKeeperCall__Inputs {
    return new SetKeeperCall__Inputs(this);
  }

  get outputs(): SetKeeperCall__Outputs {
    return new SetKeeperCall__Outputs(this);
  }
}

export class SetKeeperCall__Inputs {
  _call: SetKeeperCall;

  constructor(call: SetKeeperCall) {
    this._call = call;
  }

  get keeper(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get flag(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetKeeperCall__Outputs {
  _call: SetKeeperCall;

  constructor(call: SetKeeperCall) {
    this._call = call;
  }
}

export class SetMaximumExpectedValueCall extends ethereum.Call {
  get inputs(): SetMaximumExpectedValueCall__Inputs {
    return new SetMaximumExpectedValueCall__Inputs(this);
  }

  get outputs(): SetMaximumExpectedValueCall__Outputs {
    return new SetMaximumExpectedValueCall__Outputs(this);
  }
}

export class SetMaximumExpectedValueCall__Inputs {
  _call: SetMaximumExpectedValueCall;

  constructor(call: SetMaximumExpectedValueCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetMaximumExpectedValueCall__Outputs {
  _call: SetMaximumExpectedValueCall;

  constructor(call: SetMaximumExpectedValueCall) {
    this._call = call;
  }
}

export class SetMaximumLossCall extends ethereum.Call {
  get inputs(): SetMaximumLossCall__Inputs {
    return new SetMaximumLossCall__Inputs(this);
  }

  get outputs(): SetMaximumLossCall__Outputs {
    return new SetMaximumLossCall__Outputs(this);
  }
}

export class SetMaximumLossCall__Inputs {
  _call: SetMaximumLossCall;

  constructor(call: SetMaximumLossCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetMaximumLossCall__Outputs {
  _call: SetMaximumLossCall;

  constructor(call: SetMaximumLossCall) {
    this._call = call;
  }
}

export class SetMinimumCollateralizationCall extends ethereum.Call {
  get inputs(): SetMinimumCollateralizationCall__Inputs {
    return new SetMinimumCollateralizationCall__Inputs(this);
  }

  get outputs(): SetMinimumCollateralizationCall__Outputs {
    return new SetMinimumCollateralizationCall__Outputs(this);
  }
}

export class SetMinimumCollateralizationCall__Inputs {
  _call: SetMinimumCollateralizationCall;

  constructor(call: SetMinimumCollateralizationCall) {
    this._call = call;
  }

  get value(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetMinimumCollateralizationCall__Outputs {
  _call: SetMinimumCollateralizationCall;

  constructor(call: SetMinimumCollateralizationCall) {
    this._call = call;
  }
}

export class SetPendingAdminCall extends ethereum.Call {
  get inputs(): SetPendingAdminCall__Inputs {
    return new SetPendingAdminCall__Inputs(this);
  }

  get outputs(): SetPendingAdminCall__Outputs {
    return new SetPendingAdminCall__Outputs(this);
  }
}

export class SetPendingAdminCall__Inputs {
  _call: SetPendingAdminCall;

  constructor(call: SetPendingAdminCall) {
    this._call = call;
  }

  get value(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetPendingAdminCall__Outputs {
  _call: SetPendingAdminCall;

  constructor(call: SetPendingAdminCall) {
    this._call = call;
  }
}

export class SetProtocolFeeCall extends ethereum.Call {
  get inputs(): SetProtocolFeeCall__Inputs {
    return new SetProtocolFeeCall__Inputs(this);
  }

  get outputs(): SetProtocolFeeCall__Outputs {
    return new SetProtocolFeeCall__Outputs(this);
  }
}

export class SetProtocolFeeCall__Inputs {
  _call: SetProtocolFeeCall;

  constructor(call: SetProtocolFeeCall) {
    this._call = call;
  }

  get value(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetProtocolFeeCall__Outputs {
  _call: SetProtocolFeeCall;

  constructor(call: SetProtocolFeeCall) {
    this._call = call;
  }
}

export class SetProtocolFeeReceiverCall extends ethereum.Call {
  get inputs(): SetProtocolFeeReceiverCall__Inputs {
    return new SetProtocolFeeReceiverCall__Inputs(this);
  }

  get outputs(): SetProtocolFeeReceiverCall__Outputs {
    return new SetProtocolFeeReceiverCall__Outputs(this);
  }
}

export class SetProtocolFeeReceiverCall__Inputs {
  _call: SetProtocolFeeReceiverCall;

  constructor(call: SetProtocolFeeReceiverCall) {
    this._call = call;
  }

  get value(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetProtocolFeeReceiverCall__Outputs {
  _call: SetProtocolFeeReceiverCall;

  constructor(call: SetProtocolFeeReceiverCall) {
    this._call = call;
  }
}

export class SetSentinelCall extends ethereum.Call {
  get inputs(): SetSentinelCall__Inputs {
    return new SetSentinelCall__Inputs(this);
  }

  get outputs(): SetSentinelCall__Outputs {
    return new SetSentinelCall__Outputs(this);
  }
}

export class SetSentinelCall__Inputs {
  _call: SetSentinelCall;

  constructor(call: SetSentinelCall) {
    this._call = call;
  }

  get sentinel(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get flag(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetSentinelCall__Outputs {
  _call: SetSentinelCall;

  constructor(call: SetSentinelCall) {
    this._call = call;
  }
}

export class SetTokenAdapterCall extends ethereum.Call {
  get inputs(): SetTokenAdapterCall__Inputs {
    return new SetTokenAdapterCall__Inputs(this);
  }

  get outputs(): SetTokenAdapterCall__Outputs {
    return new SetTokenAdapterCall__Outputs(this);
  }
}

export class SetTokenAdapterCall__Inputs {
  _call: SetTokenAdapterCall;

  constructor(call: SetTokenAdapterCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get adapter(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SetTokenAdapterCall__Outputs {
  _call: SetTokenAdapterCall;

  constructor(call: SetTokenAdapterCall) {
    this._call = call;
  }
}

export class SetTransferAdapterAddressCall extends ethereum.Call {
  get inputs(): SetTransferAdapterAddressCall__Inputs {
    return new SetTransferAdapterAddressCall__Inputs(this);
  }

  get outputs(): SetTransferAdapterAddressCall__Outputs {
    return new SetTransferAdapterAddressCall__Outputs(this);
  }
}

export class SetTransferAdapterAddressCall__Inputs {
  _call: SetTransferAdapterAddressCall;

  constructor(call: SetTransferAdapterAddressCall) {
    this._call = call;
  }

  get transferAdapterAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetTransferAdapterAddressCall__Outputs {
  _call: SetTransferAdapterAddressCall;

  constructor(call: SetTransferAdapterAddressCall) {
    this._call = call;
  }
}

export class SetTransmuterCall extends ethereum.Call {
  get inputs(): SetTransmuterCall__Inputs {
    return new SetTransmuterCall__Inputs(this);
  }

  get outputs(): SetTransmuterCall__Outputs {
    return new SetTransmuterCall__Outputs(this);
  }
}

export class SetTransmuterCall__Inputs {
  _call: SetTransmuterCall;

  constructor(call: SetTransmuterCall) {
    this._call = call;
  }

  get value(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetTransmuterCall__Outputs {
  _call: SetTransmuterCall;

  constructor(call: SetTransmuterCall) {
    this._call = call;
  }
}

export class SetUnderlyingTokenEnabledCall extends ethereum.Call {
  get inputs(): SetUnderlyingTokenEnabledCall__Inputs {
    return new SetUnderlyingTokenEnabledCall__Inputs(this);
  }

  get outputs(): SetUnderlyingTokenEnabledCall__Outputs {
    return new SetUnderlyingTokenEnabledCall__Outputs(this);
  }
}

export class SetUnderlyingTokenEnabledCall__Inputs {
  _call: SetUnderlyingTokenEnabledCall;

  constructor(call: SetUnderlyingTokenEnabledCall) {
    this._call = call;
  }

  get underlyingToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetUnderlyingTokenEnabledCall__Outputs {
  _call: SetUnderlyingTokenEnabledCall;

  constructor(call: SetUnderlyingTokenEnabledCall) {
    this._call = call;
  }
}

export class SetYieldTokenEnabledCall extends ethereum.Call {
  get inputs(): SetYieldTokenEnabledCall__Inputs {
    return new SetYieldTokenEnabledCall__Inputs(this);
  }

  get outputs(): SetYieldTokenEnabledCall__Outputs {
    return new SetYieldTokenEnabledCall__Outputs(this);
  }
}

export class SetYieldTokenEnabledCall__Inputs {
  _call: SetYieldTokenEnabledCall;

  constructor(call: SetYieldTokenEnabledCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetYieldTokenEnabledCall__Outputs {
  _call: SetYieldTokenEnabledCall;

  constructor(call: SetYieldTokenEnabledCall) {
    this._call = call;
  }
}

export class SnapCall extends ethereum.Call {
  get inputs(): SnapCall__Inputs {
    return new SnapCall__Inputs(this);
  }

  get outputs(): SnapCall__Outputs {
    return new SnapCall__Outputs(this);
  }
}

export class SnapCall__Inputs {
  _call: SnapCall;

  constructor(call: SnapCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SnapCall__Outputs {
  _call: SnapCall;

  constructor(call: SnapCall) {
    this._call = call;
  }
}

export class TransferDebtV1Call extends ethereum.Call {
  get inputs(): TransferDebtV1Call__Inputs {
    return new TransferDebtV1Call__Inputs(this);
  }

  get outputs(): TransferDebtV1Call__Outputs {
    return new TransferDebtV1Call__Outputs(this);
  }
}

export class TransferDebtV1Call__Inputs {
  _call: TransferDebtV1Call;

  constructor(call: TransferDebtV1Call) {
    this._call = call;
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get debt(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferDebtV1Call__Outputs {
  _call: TransferDebtV1Call;

  constructor(call: TransferDebtV1Call) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get shares(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class WithdrawFromCall extends ethereum.Call {
  get inputs(): WithdrawFromCall__Inputs {
    return new WithdrawFromCall__Inputs(this);
  }

  get outputs(): WithdrawFromCall__Outputs {
    return new WithdrawFromCall__Outputs(this);
  }
}

export class WithdrawFromCall__Inputs {
  _call: WithdrawFromCall;

  constructor(call: WithdrawFromCall) {
    this._call = call;
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get yieldToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get shares(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class WithdrawFromCall__Outputs {
  _call: WithdrawFromCall;

  constructor(call: WithdrawFromCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class WithdrawUnderlyingCall extends ethereum.Call {
  get inputs(): WithdrawUnderlyingCall__Inputs {
    return new WithdrawUnderlyingCall__Inputs(this);
  }

  get outputs(): WithdrawUnderlyingCall__Outputs {
    return new WithdrawUnderlyingCall__Outputs(this);
  }
}

export class WithdrawUnderlyingCall__Inputs {
  _call: WithdrawUnderlyingCall;

  constructor(call: WithdrawUnderlyingCall) {
    this._call = call;
  }

  get yieldToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get shares(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get minimumAmountOut(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class WithdrawUnderlyingCall__Outputs {
  _call: WithdrawUnderlyingCall;

  constructor(call: WithdrawUnderlyingCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class WithdrawUnderlyingFromCall extends ethereum.Call {
  get inputs(): WithdrawUnderlyingFromCall__Inputs {
    return new WithdrawUnderlyingFromCall__Inputs(this);
  }

  get outputs(): WithdrawUnderlyingFromCall__Outputs {
    return new WithdrawUnderlyingFromCall__Outputs(this);
  }
}

export class WithdrawUnderlyingFromCall__Inputs {
  _call: WithdrawUnderlyingFromCall;

  constructor(call: WithdrawUnderlyingFromCall) {
    this._call = call;
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get yieldToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get shares(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get minimumAmountOut(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class WithdrawUnderlyingFromCall__Outputs {
  _call: WithdrawUnderlyingFromCall;

  constructor(call: WithdrawUnderlyingFromCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}
